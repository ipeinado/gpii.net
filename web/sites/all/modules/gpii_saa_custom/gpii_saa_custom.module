<?php
/**
 * hook_search_api_solr_query_alter
 *
 * make the basic search translate terms if non-English
 */

require __DIR__ . '/../../../vendor/autoload.php';
use Google\Cloud\Translate\TranslateClient;

function gpii_saa_custom_search_api_solr_query_alter(&$call_args, $query) {
  $pathArray = explode('/', request_path());
  $language = $pathArray[0];
  if ($language !== 'en') {
    $googleApiKey = variable_get('GOOGLE_API_KEY');
    $clientSettings = array('key' => $googleApiKey);
    $translateSettings = array('target' => 'en');
    $translate = new TranslateClient($clientSettings);
    $result = $translate->translate($call_args['query'], $translateSettings);
    $translated = $result['text'];
    $call_args['query'] = str_replace('&quot;', '', $translated);
    // Uncomment to view/debug query string
    // drupal_set_message(json_encode($call_args), 'status');
  }
}

/**
 * @file
 *  *
 * Custom Blocks and functions related to the SAA site.
 */


/**
 * Implements hook_permission().
 */
function gpii_saa_custom_permission() {
  return array(
    'access advanced search data' => array(
      'title' => t('Access api data for advanced search'),
    ),
    'access terminal taxonomy report' => array(
      'title' => t('Access terminal taxonomy term reports.'),
    )
  );
}


/**
 * Implements hook_block_info().
 */
function gpii_saa_custom_block_info() {
  $blocks = array();
  $blocks['product_tree'] = array(
    'info' => t('Product Tree'),
    );
  $blocks['needs_tree'] = array(
    'info' => t('Needs Tree'),
  );
  $blocks['trouble_tree'] = array(
    'info' => t('Trouble Tree'),
  );
  $blocks['test_tree'] = array(
    'info' => t('Test Tree'),
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function gpii_saa_custom_block_view($delta='') {
  $block = array();

  switch($delta) {
    case 'product_tree' :
      $block['content'] = product_tree_view();
      break;
    case 'needs_tree' :
      $block['content'] = needs_tree_view();
      break;
    case 'trouble_tree' :
      $block['content'] = trouble_tree_view();
      break;
    case 'test_tree' :
      $block['content'] = test_tree_view();
      break;
  }

  return $block;
}

/**
 * Implements hook_block_view(). This blocks lists the items from the Product Categories taxonomy as an unordered list.
 */


function product_tree_view() {
$block = array();
$markup = <<<EOD
<!-- taxonomy term links -->
EOD;
  $vid = 11;
  $vdisplay = 'block_1';
  $primaryCategory = taxonomy_get_tree($vid, 0, 1);
  //dpm($primaryCategory);

  foreach ($primaryCategory as $termid) {
    $destination = drupal_get_destination();
    $link = '/reports/term-utilization/' . $termid->tid;
       $count = count(views_get_view_result('taxonomy_by_tid', $vdisplay, $termid->tid));
       //dpm(count($count));
       if ($count > 0) {
        $markup .= '<h2>' . l(t($termid->name), $link, array('attributes' => array('class' => array('taxonomy-link')))) . ' (' . t($count) . ') ' . l(t('<i class="fa fa-crosshairs" title="Products with \'' . $termid->name . '\' as their terminal record."></i><span class="sr-only">Products with \'' . $termid->name . '\' as their terminal record.</span>'), '/reports/taxonomy/terminal/' . $termid->tid, array('query' => array('destination' => $destination['destination']), 'attributes' => array('class' => array('taxonomy-link')), 'html' => TRUE)) . '</h2>';
       }
       else {
        $markup .= '<h2>' . t($termid->name) . '</h2>';
       }

       $markup .= gpii_saa_custom_list_child_terms($vid, $termid->tid, $vdisplay);
  }

  // Block output in HTML with div wrapper
  $block = array(
      '#prefix' => '<div class="gpii-product-tree">',
      '#type' => 'markup',
      '#markup' => $markup,
      '#suffix' => '</div>',
  );

  return $block;
}

function needs_tree_view() {
$block = array();
$markup = <<<EOD
<!-- taxonomy term links -->
EOD;
  $vid = 5;
  $vdisplay = 'block_2';
  $primaryCategory = taxonomy_get_tree($vid, 0, 1);
  //dpm($primaryCategory);

  foreach ($primaryCategory as $termid) {
    $link = '/reports/term-utilization/' . $termid->tid;
       $count = count(views_get_view_result('taxonomy_by_tid', $vdisplay, $termid->tid));
       //dpm(count($count));
       if ($count > 0) {
        $markup .= '<h2>' . l(t($termid->name), $link, array('attributes' => array('class' => array('taxonomy-link')))) . ' (' . t($count) . ')</h2>';
       }
       else {
        $markup .= '<h2>' . t($termid->name) . '</h2>';
       }

       $markup .= gpii_saa_custom_list_child_terms($vid, $termid->tid, $vdisplay);
  }

  // Block output in HTML with div wrapper
  $block = array(
      '#prefix' => '<div class="gpii-product-tree">',
      '#type' => 'markup',
      '#markup' => $markup,
      '#suffix' => '</div>',
  );

  return $block;
}

function trouble_tree_view() {
$block = array();
$markup = <<<EOD
<!-- taxonomy term links -->
EOD;
  $vid = 8;
  $vdisplay = 'block_2';
  $primaryCategory = taxonomy_get_tree($vid, 0, 1);
  //dpm($primaryCategory);

  foreach ($primaryCategory as $termid) {
    $link = taxonomy_term_uri($termid);
       $count = count(views_get_view_result('taxonomy_by_tid', $vdisplay, $termid->tid));
       //dpm(count($count));
       if ($count > 0) {
        $markup .= '<h2>' . l(t($termid->name), $link['path'], array('attributes' => array('class' => array('taxonomy-link')))) . ' (' . t($count) . ')</h2>';
       }
       else {
        $markup .= '<h2>' . t($termid->name) . '</h2>';
       }

       $markup .= gpii_saa_custom_child_termrefs_table($vid, $termid->tid, 'default');
  }

  // Block output in HTML with div wrapper
  $block = array(
      '#prefix' => '<div class="gpii-product-tree">',
      '#type' => 'markup',
      '#markup' => $markup,
      '#suffix' => '</div>',
  );

  return $block;
}

function test_tree_view() {
$block = array();
$markup = <<<EOD
<!-- taxonomy term links -->
EOD;
  $vid = 3;
  $vdisplay = 'block_3';
  $primaryCategory = taxonomy_get_tree($vid, 0, 1);
  //dpm($primaryCategory);

  foreach ($primaryCategory as $termid) {
    $destination = drupal_get_destination();
    $link = '/reports/term-utilization/' . $termid->tid;
       $count = count(views_get_view_result('taxonomy_by_tid', $vdisplay, $termid->tid));
       //dpm(count($count));
       if ($count > 0) {
        $markup .= '<h2>' . l(t($termid->name), $link, array('attributes' => array('class' => array('taxonomy-link')))) . ' (' . t($count) . ')' . l(t('<i class="fa fa-crosshairs" title="Products with \'' . $value->name . '\' as their terminal record."></i><span class="sr-only">Products with \'' . $value->name . '\' as their terminal record.</span>'), '/reports/taxonomy/terminal/' . $value->tid, array('query' => array('destination' => $destination['destination']), 'attributes' => array('class' => array('taxonomy-link')), 'html' => TRUE)) . '</h2>';
       }
       else {
        $markup .= '<h2>' . t($termid->name) . '</h2>';
       }

       $markup .= gpii_saa_custom_list_child_terms($vid, $termid->tid, $vdisplay);
  }

  // Block output in HTML with div wrapper
  $block = array(
      '#prefix' => '<div class="gpii-product-tree">',
      '#type' => 'markup',
      '#markup' => $markup,
      '#suffix' => '</div>',
  );

  return $block;
}

function gpii_saa_custom_list_child_terms($vid, $tid, $vdisplay) {
  $li = '';
  $destination = drupal_get_destination();
  $children = taxonomy_get_tree($vid, $tid, 1);
  if ($children) {
    $li .= '<ul>';
    foreach ($children as $key => $value) {
     $link = '/reports/term-utilization/' . $value->tid;
     $count = count(views_get_view_result('taxonomy_by_tid', $vdisplay, $value->tid));
     //dpm(count($count));
     if ($count > 0) {
      $li .= '<li>' . l(t($value->name), $link, array('attributes' => array('class' => array('taxonomy-link')))) . ' (' . t($count) . ') ' . l(t('<i class="fa fa-crosshairs" title="Products with \'' . $value->name . '\' as their terminal record."></i><span class="sr-only">Products with \'' . $value->name . '\' as their terminal record.</span>'), '/reports/taxonomy/terminal/' . $value->tid, array('query' => array('destination' => $destination['destination']), 'attributes' => array('class' => array('taxonomy-link')), 'html' => TRUE)) . '</li>' .  gpii_saa_custom_list_child_terms($vid, $value->tid, $vdisplay);
     }
     else {
      $li .= '<li>' . t($value->name) . '</li>';
     }

    }
     $li .= '</ul>';
  }

  return $li;

}

function gpii_saa_custom_child_termrefs_table($vid, $tid, $vdisplay) {
  $output = '';
  $children = taxonomy_get_tree($vid, $tid, 1);
  if ($children) {
    $output .= '<table class="table table-striped table-bordered table-responsive"><tr><th>Term</th><th>Related</th></tr>';
    foreach ($children as $key => $value) {
     $link = taxonomy_term_uri($value);
     $destination = drupal_get_destination();
     $editlink = l(t('Edit'), '/taxonomy/term/' . $value->tid . '/edit', array('query' => array('destination' => $destination['destination']), 'attributes' => array('class' => array('btn btn-sm btn-default pull-right'))));


     $result = views_embed_view('get_related_terms', $vdisplay, $value->tid);
     // dpm($result);
     // dpm(strpos($result, '<ul class="term">'));
     if (strpos($result, '<ul class="term">') !== false) {
      $output .= '<tr><td>' . l(t($value->name), $link['path'], array('attributes' => array('class' => array('taxonomy-link')))) . ' ' . $editlink . '</td><td>' . $result . '</td></tr>' .  gpii_saa_custom_child_termrefs_table($vid, $value->tid, $vdisplay);
      unset($count);
     }
     else {
      $output .= '<td>' . t($value->name) .  ' ' . $editlink . '</td><td>No related terms found. </td></tr>';
     }

    }
     $output .= '</table>';
  }

  return $output;

}


/**
 * Implements hook_form_alter().
 */
function gpii_saa_custom_form_alter(&$form, &$form_state, $form_id) {
  // add a "Cancel" button to product edit forms.
  if ($form_id == 'product_node_form') {
    // Add a cancel button.
    $form['actions']['cancel'] = array(
      '#type'   => 'submit',
      '#value'  => t('Cancel'),
      '#access' => TRUE,
      '#weight' => 15,
      '#submit' => array('gpii_saa_custom_form_cancel', 'node_form_submit_build_node'),
      '#limit_validation_errors' => array(),
    );
  }
}

/**
 * Custom cancel button callback.
 */
function gpii_saa_custom_form_cancel($form, &$form_state) {
  // if there's no destination parameter, return to the view published/draft tab
  $url = $_GET['destination'] ? $_GET['destination'] : 'node/' . arg(1);
  drupal_goto($url);
}


/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function gpii_saa_custom_form_facetapi_multiselect_form_alter(&$form, &$form_state) {
  // grab a more modern version of jQuery UI
  $path = libraries_get_path('jquery.ui');
  $form['#attached']['js'][] = $path . '/jquery-ui.min.js';

  // Add the JavaScript and CSS for the library itself.
  $path = libraries_get_path('jquery.multiselect');
  $form['#attached']['js'][] = $path . '/jquery.multiselect.min.js';
  $form['#attached']['css'][] = $path . '/jquery.multiselect.css';

  // Add a custom JavaScript file which will trigger the jQuery MultiSelect
  // widget on the correct form elements.
  $form['#attached']['js'][] = drupal_get_path('module', 'gpii_saa_custom') . '/js/gpii_saa_custom.facetapi.multiselect.js';
}


    /**
    * Implements hook_menu().
     * This is experimental code to look at whether we can bypass services and kick out some JSON that doesn't take forever and a day to load.
    */
    function gpii_saa_custom_menu() {
      // $items['api/v1/productapi'] = array( // used for testing and manipulating objects before converting to JSON
      //   'title' => 'Products API Experimentation',
      //   'page callback' => 'gpii_saa_custom_products_json',
      //   'access arguments' => array('administer content'),
      // );
      $items['api/v1/products/adv-search'] = array(
        'title' => 'Products Advanced Search Endpoint',
        'page callback' => 'gpii_saa_custom_products_advsearch',
        'access arguments' => array('access advanced search data'),
      );
      $items['api/v1/products/all'] = array(
        'title' => 'Products Endpoint',
        'page callback' => 'gpii_saa_custom_products_ulisting',
        'access arguments' => array('access advanced search data'),
      );
      $items['browse/shelf/%'] = array(
        'title' => 'Virtual Store Shelf',
        'page callback' => 'gpii_saa_custom_virtual_shelf',
        'page arguments' => array(2),
        'access arguments' => array('access content'),
      );
      $items['reports/taxonomy/terminal/%'] = array(
        'title' => 'Terminal Taxonomy Report',
        'page callback' => 'gpii_saa_custom_term_terminal',
        'page arguments' => array(3),
        'access arguments' => array('access terminal taxonomy report'),
      );
      $items['testing/sync/photos/%'] = array(
        'title' => 'Image Import Test',
        'page callback' => 'gpii_saa_custom_image_import',
        'page arguments' => array(3),
        'access arguments' => array('access terminal taxonomy report'),
      );
      $items['testing/sync/uids/%'] = array(
        'title' => 'UID Import Test',
        'page callback' => 'gpii_saa_custom_uid_import',
        'page arguments' => array(3),
        'access arguments' => array('access terminal taxonomy report'),
      );
      $items['sources/%'] = array(
        'title' => 'Database Sources',
        'page callback' => 'gpii_saa_custom_list_sources',
        'page arguments' => array(1),
        'access arguments' => array('access advanced search data'),
      );

      return $items;
    }


    /**
     * This callback is used to view a list of database source records that are related
     * to a particular UID. It calls the api.ul.gpii.net API to retrieve a list of
     * database sources for a given record and returns a list of results. If there is only
     * one source and URL assoicated with the record, users are redirected automatically.
     */

    function gpii_saa_custom_list_sources($uid) {

      $query = new EntityFieldQuery();

      $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'product')
      ->fieldCondition('field_uid', 'value', $uid, '=')
      ->addMetaData('account', user_load(1)); // Run the query as user 1.

      $result = $query->execute();

      //dsm('NID: ' . key($result['node']));

      $product = node_load(key($result['node']), NULL, true);
      //dsm($product);

      $source = filter_xss(arg(2));

      // BBC: This needs some work. Basically, it adds a timestamp to the UL_API_LOGGEDIN variable and checks to see if it's less than three hours old so that we can avoid repeat logins.

      if (variable_get('UL_API_LOGGEDIN') < (time() + 10800)) {
        //dpm('LOGGED IN ALREADY ' . variable_get('UL_API_LOGGEDIN'));
      }

      else {
        // log into the API
        $curl = curl_init();

        curl_setopt_array($curl, array(
          CURLOPT_URL => "https://api.ul.gpii.net/api/user/login",
          CURLOPT_RETURNTRANSFER => true,
          CURLOPT_ENCODING => "",
          CURLOPT_MAXREDIRS => 10,
          CURLOPT_TIMEOUT => 30,
          CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
          CURLOPT_CUSTOMREQUEST => "POST",
          CURLOPT_POSTFIELDS => "username=" . variable_get('UL_API_USERNAME') . "&password=" . variable_get('UL_API_PASSWORD'),
          CURLOPT_COOKIE => "connect.sid=s%253A7A_uuI_37dlMaF9KSsPKwUzUetB412E9.u%252Fs762fGxa4bts5XK84jDrv2pg2zfEyVPpcMBbJr5do",
          CURLOPT_COOKIEFILE => "/tmp/cookie.txt",
          CURLOPT_COOKIEJAR => "/tmp/cookie.txt",

          CURLOPT_HTTPHEADER => array(
            "accept: application/json",
            "content-type: application/x-www-form-urlencoded"
          ),
        ));

        $response = curl_exec($curl);
        $err = curl_error($curl);

        curl_close($curl);

        if ($err) {
          //dpm("cURL Error #:" . $err);
        } else {
          //dpm($response);
          variable_set('UL_API_LOGGEDIN', time());
        }
      }


      if ($source) {
        //$markup =  '<p>We have a source specified.</p>';
      }
      else {
        $markup = '<p>';

          if (arg(0) == 'node') {
            $markup .= 'This product ';
          }

          else {
            $markup .= '<a href="/node/' . $product->nid . '">' . $product->title . '</a>';
          }

          $markup .= ' is listed in the following federated databases:</p>';
      }


      $markup .= '<ul>';
      if (variable_get('UL_API_LOGGEDIN') < (time())) {


          // Get the UID from the UL source record

          $curl = curl_init();

          curl_setopt_array($curl, array(
            CURLOPT_URL => "https://api.ul.gpii.net/api/product/unified/" . $uid . "?includeSources=true",
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_ENCODING => "",
            CURLOPT_MAXREDIRS => 10,
            CURLOPT_TIMEOUT => 30,
            CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
            CURLOPT_CUSTOMREQUEST => "GET",
            CURLOPT_COOKIE => "connect.sid=s%253A7A_uuI_37dlMaF9KSsPKwUzUetB412E9.u%252Fs762fGxa4bts5XK84jDrv2pg2zfEyVPpcMBbJr5do",
            CURLOPT_COOKIEFILE => "/tmp/cookie.txt",
            CURLOPT_COOKIEJAR => "/tmp/cookie.txt",

            CURLOPT_HTTPHEADER => array(
              "accept: application/json"
            ),
          ));

          $response = curl_exec($curl);
          $err = curl_error($curl);

          curl_close($curl);

          if ($err) {
            //dpm("cURL Error #:" . $err);
          } else {
            //dpm($response);
          }

        $response = json_decode($response);
        //dpm($response->sources);

        $sources = $response->sources;


        // if a source is specified
        if ($source) {
          $markup =  '<p><a href="/node/' . $product->nid . '">' . $product->title . '</a> is a consolidation of the follwing <strong>' . check_url($source) . '</strong> source records:</p>';
          $links = array();
          foreach ($sources as $key => $value) {
            // need to add code that counts records and redirects automatically here

            if ($value->source == $source) {
              //dpm($value);
              $links[] = array(
                'lang' => $value->language,
                'OriginalUrl' => $value->sourceData->OriginalUrl,
                'EnglishUrl' => $value->sourceData->EnglishUrl,
                'name' => $value->name
                );
            }
          }

          //dpm($links);

          // if we only have one source link, take the user right to it

          if (count($links) == 1) {

            //validate the URLs
            if (isset($links[0]['OriginalUrl'])) {
              $OriginalUrl = filter_var($links[0]['OriginalUrl'], FILTER_VALIDATE_URL);
            }
            if (isset($links[0]['EnglishUrl'])) {
              $EnglishUrl =  filter_var($links[0]['EnglishUrl'], FILTER_VALIDATE_URL);
            }

            if (isset($OriginalUrl)) {
              drupal_goto($OriginalUrl, array('external' => TRUE), 303);
            }

            elseif (isset($EnglishUrl)) {
               drupal_goto($EnglishUrl, array('external' => TRUE), 303);
            }

            else {
              drupal_set_message(t('Error: Invalid Link. Please return to the previous page.'), 'error', FALSE);
            }

          }

          // Print the list of Source Records from the same database when we have more than one.
          // We don't actually get here if there's only one and the redirect above kicks in.

          foreach ($links as $key => $value) {
            $markup .= '<li lang="' . substr($value['lang'], 0, 2) . '" class="skiptranslate"><a href="' . $value['OriginalUrl'] . '">' . $value['name'] . '</a> (' . strtoupper(substr($value->language, 0, 2)) . ')</li>';
          }
        }

        // end source specified

        // if we're listing all sources
        else {
          // set an array that tracks whether we've already written a source link for this record
          $sourceDBs = array();
          foreach ($sources as $key => $value) {

            if (($value->source != 'sai') && (in_array($value->source, $sourceDBs) != 1)) {
              $markup .= '<li lang="' . substr($value->language, 0, 2) . '" class="skiptranslate"><a href="/sources/' . $uid . '/' . check_url($value->source) . '">' . $value->source . '</a> (' . strtoupper(substr($value->language, 0, 2)) . ')</li>';
            }

            // add the source to the $sourceDBs array
            $sourceDBs[] = $value->source;
          }
        }
      }


      else {
        watchdog('gpii_saa_custom', 'Unable to reach UL API.', array(), WATCHDOG_NOTICE, current_path());
        $markup .= '<li>None found</li>';
      }
      $markup .= '</ul>';

      return $markup;
    }

    /**
    * This callback is used to view a list of product records where a given taxonomy
     * term has children, but the products do not have any of those children selected.
     *
     * Note: the taxonomy_review_depth_experiment_ view can't use "Term Reference Tree"
     * or else this page returns no results. (known bug)
    */

    function gpii_saa_custom_term_terminal($tid) {
      $children = taxonomy_get_children($tid);

      $name = 'taxonomy_review_depth_experiment_';
      $display_id = 'page';

      $result = views_get_view_result($name, $display_id, $tid);

      //kpr($result);
      //kpr(array_keys($children));
      $children = array_keys($children);

      foreach ($result as $key => $value) {
        # get the terms on the node and unset the row if we find a match
        //kpr($value->_field_data['nid']['entity']);
        $terms = gpii_saa_custom_get_term_ids($value->_field_data['nid']['entity']);
        $match = array_intersect($children, $terms);
        if (count($match) > 0) {
          unset($result[$key]);
        }
      }


      $headers = array(
          'nid' => array('data' => t('NID'), 'field' => 'nid'),
          'title' => array('data' => t('Title'), 'field' => 'title'),
          'prod_categories' => array('data' => t('Product Categories'), 'field' => 'prod_categories'),
          'prod_features' => array('data' => t('Needs and Wants'), 'field' => 'prod_features'),
          'published' => array('data' => t('Published'), 'field' => 'published'),
          'ops' => array('data' => t('Operations'))
      );

      $rows = array();
      foreach ($result as $terminal_nodes) {
        if (isset($terminal_nodes->field_field_features[0]['rendered']['#markup'])) {
          $features = $terminal_nodes->field_field_features[0]['rendered']['#markup'];
        }
        else {
          $features = '';
        }

        if ($terminal_nodes->_field_data['nid']['entity']->status == '1') {
          $published = 'Yes';
        }
        else {
          $published = 'No';
        }

      $rows[$terminal_nodes->nid] = array(
       'nid' => $terminal_nodes->_field_data['nid']['entity']->nid,
       'title' => l($terminal_nodes->_field_data['nid']['entity']->title, 'node/' . $terminal_nodes->_field_data['nid']['entity']->nid),
       'prod_categories' => $terminal_nodes->field_field_product_categories1[0]['rendered']['#markup'],
       'prod_features' => $features,
       // 'terms' => implode(", ", gpii_saa_custom_get_terms($terminal_nodes->_field_data['nid']['entity'])), // allows for all terms defined below
       'published' => $published,
       'ops' => l(t('edit'), '/node/' . $terminal_nodes->_field_data['nid']['entity']->nid . '/edit', array('query' => array('destination' => current_path()),'attributes' => array('class' => array('btn', 'btn-success'))))
      );
      }

      $per_page = 25;
      // Initialize the pager
      $current_page = pager_default_initialize(count($rows), $per_page);
      // Split your list into page sized chunks
      $chunks = array_chunk($rows, $per_page, TRUE);

      $form['terminal_nodes'] = array(
        '#markup' => theme('table', array(
        'header' => $headers,
        'rows' => $chunks[$current_page],
        'attributes' => array('class' => array('terminal_nodes')),
        '#empty' =>t('No results.'),
        ))
      );


      $term = taxonomy_term_load($tid);
      $destination = drupal_get_destination();
      return '<p>The following table includes product records where <strong>' . $term->name  . ' (tid: ' . $tid . ')</strong> is the terminal item in this branch of the tree.</p><p><strong>Result Count: </strong>' . count($rows) . '</p> ' . render($form['terminal_nodes']) . theme('pager', array('quantity',count($rows))) . '<a href="/node/3244" class="btn btn-primary btn-lg"><i class="fa fa-chevron-left" style="margin-right: 0.rem;"></i> Return to Product Categories Outline</a>';
    }


    function gpii_saa_custom_get_term_ids($node) {
      $terms = array();

      // Duplicate foreach loop below - based on https://www.drupal.org/node/909968#comment-11979178
      // which was throwing a bunch of php warnings for no good reason and slowed everything way down
        if (field_get_items('node', $node, 'field_product_categories1') != '') {
          foreach (field_get_items('node', $node, 'field_product_categories1') as $item) {
            if (is_array($item) && !empty($item['tid'])) {
              $terms[] = $item['tid'];
            }
          }
        }
        if (field_get_items('node', $node, 'field_features') != '') {
          foreach (field_get_items('node', $node, 'field_features') as $item) {
            if (is_array($item) && !empty($item['tid'])) {
              $terms[] = $item['tid'];
            }
          }
        }

      return $terms;
    }
    function gpii_saa_custom_get_terms($node) {
      $terms = array();

      // Duplicate foreach loop below - based on https://www.drupal.org/node/909968#comment-11979178
      // which was throwing a bunch of php warnings for no good reason and slowed everything way down
        if (field_get_items('node', $node, 'field_product_categories1') != '') {
          foreach (field_get_items('node', $node, 'field_product_categories1') as $item) {
            if (is_array($item) && !empty($item['tid'])) {
              $terms[] = $item['tid'];
            }
          }
        }
        if (field_get_items('node', $node, 'field_features') != '') {
          foreach (field_get_items('node', $node, 'field_features') as $item) {
            if (is_array($item) && !empty($item['tid'])) {
              $terms[] = $item['tid'];
            }
          }
        }

        foreach ($terms as $key => $value) {
           $term = taxonomy_term_load($value);
           $terms[$key] = $term->name;
        }
      return $terms;
    }

    /**
    * Custom callback function used for experimenting with objects and proof of concept
    */
    function gpii_saa_custom_products_json() {
      $result = db_query('SELECT * FROM ProductsUnifiedListing LIMIT 10');
        $record = $result->fetchAll();

        // initialize a new variable for use in the output
        $output = array();
        // iterate through the records and remove null values
        foreach ($record as $key => $value) {
          $output[] = (object) array_filter((array) $value);
        }

        // trim the body field by calling text_summary and clean up the markup
        foreach ($output as $key => $value) {
          if (isset($value->body)) {
            $summary = text_summary($value->body, $value->format, 400);
            $summary = check_markup($summary, $value->format);
            $value->body = $summary;
          }

          // make needs into an object that matches the original format
          if (isset($value->needs)) {
            $tids = explode(',', $value->needs);

            foreach ($tids as $num => $id) {
              $tid[] = (object) array('tid' => $id);
            }
            $value->needs = $tid;
            // clear this after each loop
            unset($tid);
          }
        }
        //using kpr due to issue with dpm in latest bootstrap
        //kpr($output);
        return '';
    }

    /**
    * This callback is used by the advanced search nodejs application
    */
    function gpii_saa_custom_products_advsearch() {
      $result = db_query('SELECT * FROM ProductsAdvSearch');
        $record = $result->fetchAll();

        // initialize a new variable for use in the output
        $output = array();

        // iterate through the records and remove null values
        foreach ($record as $key => $value) {
          $output[] = (object) array_filter((array) $value);
        }

        // trim the body field by calling text_summary and clean up the markup
        foreach ($output as $key => $value) {
          if (isset($value->body_summary)) {
            $value->body = $value->body_summary;
          }

          elseif (isset($value->body)) {
            $summary = text_summary($value->body, $value->format, 400);
            $summary = check_markup($summary, $value->format);
            $value->body = $summary;
          }
        }

        // convert the object to JSON
        return drupal_json_output($output);
    }

    /**
    * This callback is used by the Unified Listing application to retrieve a list
     * of SAI records for comparison and synchronization.
    */
    function gpii_saa_custom_products_ulisting() {
      $result = db_query('SELECT * FROM ProductsUnifiedListing');
        $record = $result->fetchAll();

        // initialize a new variable for use in the output
        $output = array();

        // iterate through the records and remove null values
        foreach ($record as $key => $value) {
          $output[] = (object) array_filter((array) $value);
        }

        // trim the body field by calling text_summary and clean up the markup
        foreach ($output as $key => $value) {
          if (isset($value->body)) {
            $summary = text_summary($value->body, $value->format, 400);
            $summary = check_markup($summary, $value->format);
            $value->body = $summary;
          }

          // make needs into an object that matches the original format
          if (isset($value->needs)) {
            $tids = explode(',', $value->needs);

            foreach ($tids as $num => $id) {
              $tid[] = (object) array('tid' => $id);
            }
            $value->needs = $tid;
            // clear this after each loop
            unset($tid);
          }

          // make product_categories into an object that matches the original format
          if (isset($value->product_category)) {
            $tids = explode(',', $value->product_category);

            foreach ($tids as $num => $id) {
              $tid[] = (object) array('tid' => $id);
            }
            $value->product_category = $tid;
            // clear this after each loop
            unset($tid);
          }

          // make trouble taxonomy into an object that matches the original format
          if (isset($value->trouble)) {
            $tids = explode(',', $value->trouble);

            foreach ($tids as $num => $id) {
              $tid[] = (object) array('tid' => $id);
            }
            $value->trouble = $tid;
            // clear this after each loop
            unset($tid);
          }

          // make needs into an object that matches the original format
          if (isset($value->product_image)) {
            //@@ this needs to be rewritten to handle additional image fields (hidden, permission, source)
            //as well as to handle multiple values


            // alt may be empty, so set it to null if it's not available in this context
            if (!isset($value->alt)) {
              $value->alt = '';
            }
            // pull a few values out of the top level and insert them as
            // objects under product_image

            $value->product_image = (object) array(
              'fid' => $value->fid,
              'filename' => $value->filename,
              'uri' => $value->product_image,
              'alt' => $value->alt,
              'filemime' => $value->filemime,
              'filesize' => $value->filesize,
              'status' => $value->status,
              'timestamp' => $value->timestamp,
              'origname' => $value->origname,
              //'experiment' => $value->experiment
              );


          }

          // Set the status based on numerical values that the query returns
          if (isset($value->ul_status)) {
            $statuses = array(
              '0' => 'new',
              '1' => 'active',
              '2' => 'discontinued',
              '3' => 'deleted'
            );
            $value->ul_status = $statuses[$value->ul_status];
          }
          else {
            $value->ul_status = "new";
          }

          // unset variables used above
          unset($value->fid);
          unset($value->filename);
          unset($value->alt);
          unset($value->filemime);
          unset($value->filesize);
          unset($value->status);
          unset($value->timestamp);
          unset($value->origname);

        }

        // convert the object to JSON
        return drupal_json_output($output);
    }



/**
 * Implements hook_services_postprocess() to insert info about the language we're actually sending
 *
 * @@ need to add same logic for the needs and wants view
 */

function gpii_saa_custom_services_request_postprocess_alter($controller, $args, &$result) {

  //Debugging
   // print($controller['view info']['view_name']);
   // print_r($controller);
   // print_r($result);
   // exit;

   // Identify JSON returned by the documents available view and make a few adjustments to the output.
   if (isset($controller['view info'])) {
    if ($controller['view info']['view_name'] == 'product_categories') {

      // get the currently active language
      global $language ;
      $lang = $language->language ;


      foreach ($result as $key => $value) {
        // call the fuction with term id and language
        $translation_status = gpii_custom_get_translation_status($result[$key]->term_id, $lang);
        if ($translation_status > 0) {
          $result[$key]->lang = $lang;
        }
      }
    }
    if ($controller['view info']['view_name'] == 'difficulties_categories') {

      // get the currently active language
      global $language ;
      $lang = $language->language ;


      foreach ($result as $key => $value) {
        // call the fuction with term id and language
        $translation_status = gpii_custom_get_translation_status($result[$key]->term_id, $lang);
        if ($translation_status > 0) {
          $result[$key]->lang = $lang;
        }
      }
    }
    if ($controller['view info']['view_name'] == 'deleted_records') {
      foreach ($result as $key => $value) {
        if (isset($result[$key]->duplicate_nid['value'])) {
          $result[$key]->duplicate_nid = $result[$key]->duplicate_nid['value'];
        }
        else {
          unset($result[$key]->duplicate_nid);
        }
         $result[$key]->uid = $result[$key]->uid['value'];
         $result[$key]->status = 'deleted'; // set manually since this is a filter in the view itself
      }
    }
  }
}


/**
 * Implements hook_action_info() to add some custom VBO actions
 */
function gpii_saa_custom_action_info() {
  return array(
    'gpii_saa_custom_import_ul_images' => array(
      'type' => 'entity',
      'label' => t('Import new images from the Unified Listing'),
      'behavior' => array('changes_property'),
      'configurable' => FALSE,
      'vbo_configurable' => FALSE,
      'triggers' => array('any'),
    ),
    'gpii_saa_custom_import_sai_uids' => array(
      'type' => 'entity',
      'label' => t('Import UIDs from the Unified Listing DB'),
      'behavior' => array('changes_property'),
      'configurable' => FALSE,
      'vbo_configurable' => FALSE,
      'triggers' => array('any'),
    ),
    'gpii_saa_custom_remove_deleted_records' => array(
      'type' => 'entity',
      'label' => t('Check the UL API and delete record if status is deleted'),
      'behavior' => array(''),
      'configurable' => FALSE,
      'vbo_configurable' => FALSE,
      'triggers' => array('any'),
    ),
    'gpii_saa_custom_sync_needs_to_trouble' => array(
      'type' => 'entity',
      'label' => t('Update and sync trouble taxonomy terms'),
      'behavior' => array('changes_property'),
      'configurable' => FALSE,
      'vbo_configurable' => FALSE,
      'triggers' => array('any'),
    ),
  );
}


/**
 * This function is called from the action_info array above
 */

function gpii_saa_custom_import_ul_images(&$entity) {

  // call the gpii_saa_custom_image_import_vbo function
  return gpii_saa_custom_image_import_vbo($entity);
}


function gpii_saa_custom_image_import_vbo(&$entity) {
  //if the product record doesn't have a UID, there's no reason to try to continue.
  if (isset($entity->field_uid['und'][0])) {

    $original_image = field_view_field('node', $entity, 'field_product_image');

    // find out if there are any new images in the UL

    $url = 'https://api.ul.gpii.net/api/images/metadata/' . $entity->field_uid['und'][0]['value'];
    $result = file_get_contents($url);
    //dsm($result);
    $result = drupal_json_decode($result, true);
    //dsm($result[0]['image_id']);

    // Compare the original files to the new ones to see if anything should be overwritten

    $original_file_hashes = array();

    foreach ($entity->field_product_image['und'] as $key => $value) {
      $original_file_hashes[$key] = md5_file($value['uri']);
    }

    //dsm('Original Images: ' . implode(', ', $original_filenames));

    $imported_file_hashes = array();

    if ($result) {
      foreach ($result as $key => $value) {
        $imported_file_hashes[$key] = md5_file('https://api.ul.gpii.net/api/images/file/' . $value['uid'] . '/' . $value['source'] . '/' . $value['image_id']);
      }
    }


    //dsm('Imported Images: ' . implode(', ', $imported_filenames));


    $diff_files = array_diff($imported_file_hashes, $original_file_hashes);
    //drupal_set_message(count($diff_files) . t(' new files found for !link', array('!link' =>  l('node ' . $entity->nid, 'node/' . $entity->nid))));
    // dsm(implode(', ', $diff_filenames));

    if (count($diff_files)) {

      foreach ($result as $key => $value) {

          $filename = $value['image_id'];

          $image = file_get_contents('https://api.ul.gpii.net/api/images/file/' . $value['uid'] . '/' . $value['source'] . '/' . $value['image_id']);
          //dpm('https://api.ul.gpii.net/api/images/file/' . $value['uid'] . '/' . $value['source'] . '/' . $value['image_id']);
          $file = file_save_data($image, 'public://' . $filename, FILE_EXISTS_REPLACE);
          $file->alt = $value['description'];
          $file->title = $value['description'];

          //dpm($file);
          $entity->field_product_image['und'][] = (array)$file;
          //dpm($entity->field_product_image);

          // Remove the default image thumbnail if there were no images to begin with.
          //dsm($entity->field_product_image['und'][0]['filename']);

          if (isset($entity->field_product_image['und'][0]) && $entity->field_product_image['und'][0]['filename'] === 'product-default-thumb.png') {
            unset($entity->field_product_image['und'][0]);
          }
      }

      // unset all related to photo and alt text status as they will have changed as a result of the import

      $unflagids = array(
        'photo_complete',
        'photo_reviewed',
        'alt_title_complete',
        'alt_title_reviewed'
        );

      foreach ($unflagids as $key => $value) {
        $flag = flag_get_flag($value);
        $flag->flag('unflag', $entity->nid, user_load('1'), FALSE);
      }


      watchdog('gpii_saa_custom', count($diff_files) . 'new image(s) for node ' . $entity->nid . ' have been imported.', array(), WATCHDOG_NOTICE, l('view', 'node/' . $entity->nid));

      // return the modified entity to VBO for processing
      return $entity;

    }
  }

  return;

}


/**
 * This function is called from the action_info array above
 */

function gpii_saa_custom_import_sai_uids(&$entity) {
  // if there's no value for UID, then hit the API to find it
  if (!isset($entity->field_uid['und'][0]['value'])) {

    $uid = gpii_saa_custom_uid_import($entity->nid);

    if (isset($uid)) {
      $entity->field_uid['und'][0]['value'] = $uid;

      watchdog('gpii_saa_custom', 'Node ' . $entity->nid . ' has been assigned UID ' . $uid  . '.', array(), WATCHDOG_NOTICE, l('view', 'node/' . $entity->nid));
    }

    else {
      watchdog('gpii_saa_custom', 'Node ' . $entity->nid . ' is not available in the UL API.', array(), WATCHDOG_NOTICE, l('view', 'node/' . $entity->nid));
    }

    // return the modified entity to VBO for processing
    return $entity;
  }

  return;
}

/**
 * Test function for UID import returns a UID if one exists in the Unified listing data set
 */

function gpii_saa_custom_uid_import($nid) {
  $product = node_load($nid, NULL, true);
  //kpr($product);

  // find out if the UL has a UID for this record

  // log into the API

  $curl = curl_init();

  curl_setopt_array($curl, array(
    CURLOPT_URL => "https://api.ul.gpii.net/api/user/login",
    CURLOPT_RETURNTRANSFER => true,
    CURLOPT_ENCODING => "",
    CURLOPT_MAXREDIRS => 10,
    CURLOPT_TIMEOUT => 30,
    CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
    CURLOPT_CUSTOMREQUEST => "POST",
    CURLOPT_POSTFIELDS => "username=" . variable_get('UL_API_USERNAME') . "&password=" . variable_get('UL_API_PASSWORD'),
    CURLOPT_COOKIE => "connect.sid=s%253A7A_uuI_37dlMaF9KSsPKwUzUetB412E9.u%252Fs762fGxa4bts5XK84jDrv2pg2zfEyVPpcMBbJr5do",
    CURLOPT_COOKIEFILE => "/tmp/cookie.txt",
    CURLOPT_COOKIEJAR => "/tmp/cookie.txt",

    CURLOPT_HTTPHEADER => array(
      "accept: application/json",
      "content-type: application/x-www-form-urlencoded"
    ),
  ));

  $response = curl_exec($curl);
  $err = curl_error($curl);

  curl_close($curl);

  if ($err) {
    dpm("cURL Error #:" . $err);
  } else {
    //dpm($response);
  }

  // Get the UID from the UL source record

  $curl2 = curl_init();

  curl_setopt_array($curl2, array(
    CURLOPT_URL => "https://api.ul.gpii.net/api/product/sai/" . $nid . "?includeSources=true",
    CURLOPT_RETURNTRANSFER => true,
    CURLOPT_ENCODING => "",
    CURLOPT_MAXREDIRS => 10,
    CURLOPT_TIMEOUT => 30,
    CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
    CURLOPT_CUSTOMREQUEST => "GET",
    CURLOPT_COOKIE => "connect.sid=s%253A7A_uuI_37dlMaF9KSsPKwUzUetB412E9.u%252Fs762fGxa4bts5XK84jDrv2pg2zfEyVPpcMBbJr5do",
    CURLOPT_COOKIEFILE => "/tmp/cookie.txt",
    CURLOPT_COOKIEJAR => "/tmp/cookie.txt",

    CURLOPT_HTTPHEADER => array(
      "accept: application/json"
    ),
  ));

  $response = curl_exec($curl2);
  $err = curl_error($curl2);

  curl_close($curl2);

  if ($err) {
    dpm("cURL Error #:" . $err);
  } else {
    //dpm($response);
  }

  $response = json_decode($response);

  //dpm($response->uid);

  return $response->uid;
}

/**
 * This function is really just for testing at this point. @@ remove before launch
 *
 */

function gpii_saa_custom_image_import($uid) {
  //dsm('UID: ' . $uid);

  $query = new EntityFieldQuery();

  $query->entityCondition('entity_type', 'node')
  ->entityCondition('bundle', 'product')
  ->fieldCondition('field_uid', 'value', $uid, '=')
  ->addMetaData('account', user_load(1)); // Run the query as user 1.

  $result = $query->execute();

  //dsm('NID: ' . key($result['node']));

  $product = node_load(key($result['node']), NULL, true);
  //dsm($product);


  if (isset($product)) {
    $original_image = field_view_field('node', $product, 'field_product_image');

    $markup = '';

    $markup .= '<h2>Original Image(s)</h2>';
    $markup .= render($original_image);

    // find out if there are any new images in the UL

    $url = 'https://api.ul.gpii.net/api/images/metadata/' . $uid;
    $result = file_get_contents($url);
    $result = json_decode($result, true);
    //dsm($result);

    // Compare the original files to the new ones to see if anything should be overwritten

    $original_file_hashes = array();

    foreach ($original_image['#items'] as $key => $value) {
      $original_file_hashes[$key] = md5_file($value['uri']);
    }

    dsm('Original Images: ' . implode(', ', $original_file_hashes));

    $imported_file_hashes = array();

    foreach ($result as $key => $value) {
      $imported_file_hashes[$key] = md5_file('https://api.ul.gpii.net/api/images/file/' . $value['uid'] . '/' . $value['source'] . '/' . $value['image_id']);
    }

    dsm('Imported Images: ' . implode(', ', $imported_file_hashes));


    $diff_files = array_diff($imported_file_hashes, $original_file_hashes);

    dsm(count($diff_files) . ' new files found.');

    if (count($diff_files)) {
      // create an array that we can go through and do housekeeping on later
      $housekeeping = array();

      foreach ($result as $key => $value) {

        // BBC: not sure the first if statement below is needed anymore
        $filename = $value['image_id'];

        // if (recursive_array_search($filename, $product->field_product_image) !== false) {
        //   // we already have this file, so don't do anything
        //   // @@ this assumes that we don't have any updated text alternatives
        //   dsm("DUPLICATE FOUND");
        // }

        // else {
          $image = file_get_contents('https://api.ul.gpii.net/api/images/file/' . $value['uid'] . '/' . $value['source'] . '/' . $value['image_id']);
          //dpm('https://api.ul.gpii.net/api/images/file/' . $value['uid'] . '/' . $value['source'] . '/' . $value['image_id']);
          $file = file_save_data($image, 'public://' . $filename, FILE_EXISTS_REPLACE);
          $file->alt = $value['description'];
          $file->title = $value['description'];
          //$file->copyright = 'TEST';

          //dsm($file);
          $product->field_product_image['und'][] = (array)$file;
          dpm($product->field_product_image);
          $housekeeping[] = $filename;
        //}

      }

      // since we have new images, go ahead and save the updated product
      // @@ keep it from blowing away alt text and status fields
      node_save($product);

      foreach ($housekeeping as $value) {
        // clean up the previously uploaded file
        file_unmanaged_delete('public://' . $value);
      }
    }



  }
  dsm($product->field_product_image['und']);
  return $markup;

}

/**
 * Custom function called by gpii_saa_custom_image_import to recursively search an array
 *
 * @param      <type>  $needle    The needle
 * @param      <type>  $haystack  The haystack
 *
 * @return     <type>  ( description_of_the_return_value )
 */

function recursive_array_search($needle,$haystack) {
    foreach($haystack as $key=>$value) {
        $current_key=$key;
        if($needle===$value OR (is_array($value) && recursive_array_search($needle,$value) !== false)) {
            return $current_key;
        }
    }
    return false;
}



/**
 * This function checks with the UL API to see if it also has a status
 * of deleted. If it does, the node is deleted.
 */

function gpii_saa_custom_remove_deleted_records(&$entity) {
  // be sure that we have a UID and that the current status for the node is 'deleted'
  if ($entity->field_status['und'][0]['value'] == '3' && isset($entity->field_uid['und'][0]['value'])) {

    // call gpii_saa_custom_delete_records_vbo() to find out if the UL API agrees that the
    // status is 'deleted'
    $apiStatus = gpii_saa_custom_delete_records_vbo($entity->field_uid['und'][0]['value']);
    //dpm($apiStatus);
    if ($apiStatus == 'deleted') {
      // log the deletion before we lose access to the variables we need to create the log entry.
      watchdog('gpii_saa_custom', 'Node ' . $entity->nid . ' (UID: ' . $entity->field_uid['und'][0]['value'] . ') has been deleted.', array(), WATCHDOG_NOTICE, l('view', 'node/' . $entity->nid));
      // go ahead and delete the node
      node_delete($entity->nid);
    }

    elseif ($apiStatus == false) {
      // log a failure to get a response from the API.
      watchdog('gpii_saa_custom', 'Node ' . $entity->nid . ' got no response from the UL API.', array(), WATCHDOG_NOTICE, l('view', 'node/' . $entity->nid));
    }

    else {
      watchdog('gpii_saa_custom', 'Node ' . $entity->nid . ' is not marked for deletion in the UL API.', array(), WATCHDOG_NOTICE, l('view', 'node/' . $entity->nid));
    }

    // return the modified entity to VBO for processing
    return;
  }

  return;

}


function gpii_saa_custom_delete_records_vbo($uid) {
  //dsm("https://api.ul.gpii.net/api/product/unified/" . $uid);

  // Get the status for this record from the UL API

  $curl = curl_init();

  curl_setopt_array($curl, array(
    CURLOPT_URL => "https://api.ul.gpii.net/api/product/unified/" . $uid,
    CURLOPT_RETURNTRANSFER => true,
    CURLOPT_ENCODING => "",
    CURLOPT_MAXREDIRS => 10,
    CURLOPT_TIMEOUT => 30,
    CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,
    CURLOPT_CUSTOMREQUEST => "GET",
    CURLOPT_FOLLOWLOCATION => true, // follow 301 redirects!!!!
    CURLOPT_COOKIE => "connect.sid=s%253A7A_uuI_37dlMaF9KSsPKwUzUetB412E9.u%252Fs762fGxa4bts5XK84jDrv2pg2zfEyVPpcMBbJr5do",
    CURLOPT_COOKIEFILE => "/tmp/cookie.txt",
    CURLOPT_COOKIEJAR => "/tmp/cookie.txt",
    CURLOPT_HTTPHEADER => array(
      "accept: application/json"
    ),
  ));

  $response = curl_exec($curl);
  $err = curl_error($curl);

  curl_close($curl);

  if ($err) {
    watchdog('gpii_saa_custom', $err , array(), WATCHDOG_NOTICE, l('view', 'node/' . $entity->nid));
    // dpm("cURL Error #:" . $err);
  } else {
    //dpm($response);
  }

  $response = json_decode($response);

  //dsm($response->status);

  if (isset($response)) {
    return $response->status;
  }

  else {
    return false;
  }
}


/**
 * This function looks at the needs and wants (features) associated with a node and
 * sets values for the "things I have trouble with" taxonomy
 */

function gpii_saa_custom_sync_needs_to_trouble(&$entity) {
  // be sure that the record has some terms from the needs and wants tree associated with it before proceeding
  //dpm('Needs Count: ' . count($entity->field_features['und']));
  if (count($entity->field_features['und']) > 0) {

    // call gpii_saa_custom_sync_needs_to_trouble() with the entity's nid to handle the updates
    $trouble_terms = gpii_saa_custom_sync_needs_to_trouble_vbo($entity->field_features['und']);

    //dpm(implode(', ', $trouble_terms));

    // if we get an array of trouble taxonomy terms back, go through and each of them to the entity and save
    if (isset($trouble_terms)) {
      // remove any old trouble taxonomy refs
      unset($entity->field_trouble_with['und']);

      // create an empty array to hold parents of terms referenced
      $parents = array();
      foreach ($trouble_terms as $key => $value) {
        //dpm($key . '-' . $value);
        // Set lineage no longer works because virutal stores need to reference only some children
        // Therefore, check to see if the trouble term has parents and set those too. We only have to check once because this tree is only 2 levels deep.
        $parent = taxonomy_get_parents($value);

        // add the parent key to an array by getting the key of the array of objects returned by taxonomy_get_parents
        $parents[] = key($parent);

        $entity->field_trouble_with['und'][] = array('tid' => $value);
      }


      // add the parent terms
      $parents = array_unique($parents);
      if (count($parents) > 0) {
        foreach ($parents as $key => $value) {
          $entity->field_trouble_with['und'][] = array('tid' => $value);
        }
      }


      watchdog('gpii_saa_custom', 'Node ' . $entity->nid . ' has been updated.', array(), WATCHDOG_NOTICE, l('view', 'node/' . $entity->nid));
    }

    // return the modified entity to VBO for processing
    return $entity;
  }

  return;

}


function gpii_saa_custom_sync_needs_to_trouble_vbo($features) {

  foreach ($features as $key => $value) {
    // query the trouble view with the term ID to find out which terms from the
    // trouble taxonomy reference this term
    $results = views_get_view_result('trouble', 'default', $value['tid']);

    foreach ($results as $key => $value) {
      $trouble_terms[] = $value->tid;
    }
  }

  return $trouble_terms;
}


function gpii_saa_custom_virtual_shelf($tid) {

  // include browse virtual store functions
  module_load_include('inc', 'gpii_saa_custom', 'browse_virtual_stores');


  return virtual_shelf($tid);
}
